<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Monitor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üì°</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 20px; margin: 0; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: #00ff88; text-align: center; margin-bottom: 10px; }
        .status { text-align: center; color: #888; margin-bottom: 20px; }
        .time-controls { display: flex; gap: 10px; justify-content: center; margin-bottom: 30px; flex-wrap: wrap; }
        .time-btn { background: #2a2a2a; color: #888; border: 1px solid #333; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; }
        .time-btn.active { background: #00ff88; color: #000; border-color: #00ff88; font-weight: bold; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 8px; margin-bottom: 12px; max-width: 100%; }
        @media (min-width: 1000px) { .summary { grid-template-columns: repeat(4, 1fr); } }
        .stat-card { background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%); padding: 12px; border-radius: 6px; border: 1px solid #333; position: relative; }
        .stat-card h3 { margin: 0 0 6px 0; color: #888; font-size: 11px; text-transform: uppercase; display: inline-block; }
        .stat-card .value { font-size: 28px; font-weight: bold; color: #00ff88; }
        .stat-card .subvalue { font-size: 10px; color: #666; margin-top: 3px; }
        .info-icon { display: inline-block; width: 12px; height: 12px; line-height: 12px; text-align: center; background: #444; color: #aaa; border-radius: 50%; font-size: 9px; margin-left: 4px; cursor: help; position: relative; }
        .info-icon:hover { background: #555; color: #fff; }
        .tooltip { visibility: hidden; position: absolute; z-index: 1000; background: #2a2a2a; color: #ddd; padding: 8px; border-radius: 4px; font-size: 11px; border: 1px solid #444; width: 200px; left: 50%; transform: translateX(-50%); bottom: 100%; margin-bottom: 5px; text-transform: none; font-weight: normal; }
        .info-icon:hover .tooltip { visibility: visible; }
        .stat-card .value { font-size: 32px; font-weight: bold; color: #00ff88; }
        .stat-card.warning .value { color: #ffaa00; }
        .stat-card.error .value { color: #ff4444; }
        .charts { display: grid; grid-template-columns: 1fr; gap: 30px; }
        .chart-container { background: #1a1a1a; padding: 20px; border-radius: 10px; border: 1px solid #333; }
        .chart-container h2 { margin: 0 0 15px 0; color: #00ff88; font-size: 18px; }
        .chart-subtitle { color: #666; font-size: 12px; margin: -10px 0 15px 0; font-style: italic; }
        canvas { max-height: 300px; }
        @media (max-width: 768px) { .summary { grid-template-columns: 1fr 1fr; } }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); color: #00ff88; padding: 20px 40px; border-radius: 10px; font-size: 18px; z-index: 9999; display: none; }
        .loading.show { display: block; }
    </style>
</head>
<body>
    <div class="loading" id="loadingIndicator">‚è≥ Loading data...</div>
    <div class="container">
        <h1>üåê Network Monitor</h1>
        <div class="status" id="lastUpdate">Loading... (Times shown in Mountain Time) | Node: <span id="nodeId">-</span></div>
        
        <div class="time-controls">
            <button class="time-btn" onclick="updateRange(15)">15 Min</button>
            <button class="time-btn" onclick="updateRange(30)">30 Min</button>
            <button class="time-btn" onclick="updateRange(60)">1 Hour</button>
            <button class="time-btn" onclick="updateRange(360)">6 Hours</button>
            <button class="time-btn" onclick="updateRange(720)">12 Hours</button>
            <button class="time-btn active" onclick="updateRange(1440)">24 Hours</button>
            <button class="time-btn" onclick="updateRange(4320)">3 Days</button>
            <button class="time-btn" onclick="updateRange(10080)">7 Days</button>
            <button class="time-btn" onclick="updateRange(null)">All</button>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">üìä Overview</h2>
        <div class="summary">
            <div class="stat-card"><h3>Total Tests</h3><div class="value" id="totalTests">0</div></div>
            <div class="stat-card" id="highLatencyCard"><h3>High Latency<span class="info-icon">i<span class="tooltip">Tests with >100ms latency to Google DNS</span></span></h3><div class="value" id="highLatency">0</div></div>
            <div class="stat-card" id="failuresCard"><h3>Failures<span class="info-icon">i<span class="tooltip">Tests where ping completely failed</span></span></h3><div class="value" id="failures">0</div></div>
            <div class="stat-card"><h3>Modem Uptime<span class="info-icon">i<span class="tooltip">Time since last modem restart</span></span></h3><div class="value" id="modemUptime">-</div><div class="subvalue" id="modemUptimeChecked">-</div></div>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">üåê Google DNS (8.8.8.8)</h2>
        <div class="summary">
            <div class="stat-card" id="avgLatencyCard"><h3>Avg Latency<span class="info-icon">i<span class="tooltip">Average ping time to Google DNS. Good baseline for internet health</span></span></h3><div class="value" id="avgLatency">0<span style="font-size: 16px;">ms</span></div></div>
            <div class="stat-card" id="avgPacketLossCard"><h3>Avg Packet Loss<span class="info-icon">i<span class="tooltip">Percentage of packets lost to Google DNS across all tests</span></span></h3><div class="value" id="avgPacketLoss">0<span style="font-size: 16px;">%</span></div></div>
            <div class="stat-card" id="googlePacketLossCard"><h3>Loss Events<span class="info-icon">i<span class="tooltip">Number of tests with any packet loss to Google DNS</span></span></h3><div class="value" id="googlePacketLossCount">0</div></div>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">üì° CMTS (70.77.96.1)</h2>
        <div class="summary">
            <div class="stat-card" id="avgCmtsLatencyCard"><h3>Avg Latency<span class="info-icon">i<span class="tooltip">Average ping time to CMTS (first hop). Should be very low</span></span></h3><div class="value" id="avgCmtsLatency">0<span style="font-size: 16px;">ms</span></div></div>
            <div class="stat-card" id="avgCmtsPacketLossCard"><h3>Avg Packet Loss<span class="info-icon">i<span class="tooltip">Percentage of packets lost to CMTS. Indicates ISP connection issues</span></span></h3><div class="value" id="avgCmtsPacketLoss">0<span style="font-size: 16px;">%</span></div></div>
            <div class="stat-card" id="cmtsPacketLossCard"><h3>Loss Events<span class="info-icon">i<span class="tooltip">Number of tests with any packet loss to CMTS (first hop)</span></span></h3><div class="value" id="cmtsPacketLossCount">0</div></div>
            <div class="stat-card" id="latencyDiffCard"><h3>vs Google Diff<span class="info-icon">i<span class="tooltip">Latency difference between CMTS and Google. Should be near 0ms since CMTS is first hop</span></span></h3><div class="value" id="latencyDiff">0<span style="font-size: 16px;">ms</span></div></div>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">üöÄ Speed Tests</h2>
        <div class="summary">
            <div class="stat-card"><h3>Download<span class="info-icon">i<span class="tooltip">Latest download speed test result</span></span></h3><div class="value" id="latestDownload">-<span style="font-size: 16px;">Mbps</span></div><div class="subvalue" id="downloadTime">-</div></div>
            <div class="stat-card"><h3>Upload<span class="info-icon">i<span class="tooltip">Latest upload speed test result</span></span></h3><div class="value" id="latestUpload">-<span style="font-size: 16px;">Mbps</span></div><div class="subvalue" id="uploadTime">-</div></div>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">üì∂ Modem Signals</h2>
        <div class="summary">
            <div class="stat-card" id="modemDsSNRCard"><h3>DS SNR<span class="info-icon">i<span class="tooltip">Downstream Signal-to-Noise Ratio. Good: >30dB. Low values indicate line noise</span></span></h3><div class="value" id="modemDsSNR">-<span style="font-size: 16px;">dB</span></div><div class="subvalue" id="modemDsSNRRange">-</div></div>
            <div class="stat-card" id="modemDsPowerCard"><h3>DS Power<span class="info-icon">i<span class="tooltip">Downstream Power Level. Good: -7 to +7 dBmV. Outside range indicates signal strength issues</span></span></h3><div class="value" id="modemDsPower">-<span style="font-size: 16px;">dBmV</span></div><div class="subvalue" id="modemDsPowerRange">-</div></div>
            <div class="stat-card" id="modemUsPowerCard"><h3>US Power<span class="info-icon">i<span class="tooltip">Upstream Power Level. Good: 35-51 dBmV. High values mean modem is working harder to reach CMTS</span></span></h3><div class="value" id="modemUsPower">-<span style="font-size: 16px;">dBmV</span></div><div class="subvalue" id="modemUsPowerRange">-</div></div>
        </div>
        
        <h2 style="color: #00ff88; margin: 20px 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px;">‚ö†Ô∏è Worst Channel Errors <span style="font-size: 11px; color: #666; font-weight: normal; text-transform: none;">(cumulative since modem reboot)</span></h2>
        <div class="summary">
            <div class="stat-card"><h3>Channel ID<span class="info-icon">i<span class="tooltip">Downstream channel with most errors. Each channel is a 6MHz frequency band</span></span></h3><div class="value" id="worstChannelId">-</div></div>
            <div class="stat-card" id="worstChannelCorrCard"><h3>Correctable<span class="info-icon">i<span class="tooltip">Errors the modem fixed. High values indicate line degradation</span></span></h3><div class="value" id="worstChannelCorr">-</div></div>
            <div class="stat-card" id="worstChannelUncorrCard"><h3>Uncorrectable<span class="info-icon">i<span class="tooltip">Errors causing data loss. These directly cause packet loss and outages</span></span></h3><div class="value" id="worstChannelUncorr">-</div></div>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <h2>üìà Latency & Packet Loss - Google DNS (8.8.8.8)</h2>
                <div class="chart-subtitle">Note: 0 ms latency indicates 100% packet loss and could not be calculated. Small latency spikes every 5 minutes (when speed tests run) are normal due to network saturation during bandwidth testing. Click legend items to show/hide lines.</div>
                <canvas id="latencyChart"></canvas>
                <div id="latencyRestarts" style="font-size: 10px; color: #ff8800; margin-top: 5px;"></div>
            </div>
            
            <div class="chart-container">
                <h2>üì° Latency & Packet Loss - CMTS (70.77.96.1)</h2>
                <div class="chart-subtitle">First hop after your network (Cable Modem Termination System). Comparing this to Google helps identify if issues are with your ISP or upstream. Small latency spikes every 5 minutes (when speed tests run) are normal due to network saturation during bandwidth testing. Click legend items to show/hide lines.</div>
                <canvas id="cmtsChart"></canvas>
                <div id="cmtsRestarts" style="font-size: 10px; color: #ff8800; margin-top: 5px;"></div>
            </div>
            
            <div class="chart-container" id="speedChartContainer">
                <h2>üìä Upload & Download Speed (Mbps)</h2>
                <div class="chart-subtitle">Testing via Shaw Communications Calgary server. Note: 0 Mbps indicates speedtest could not complete due to connectivity issues. This server is limited by a 1 Gbps switch, so speeds will not reach the full 1000+ Mbps connection. <strong>Latency spikes may occur during speed tests due to bandwidth saturation.</strong> Click legend items to show/hide lines.</div>
                <canvas id="speedChart"></canvas>
                <div id="speedRestarts" style="font-size: 10px; color: #ff8800; margin-top: 5px;"></div>
            </div>
            
            <div class="chart-container">
                <h2>üì° Modem Signal Levels</h2>
                <div class="chart-subtitle">XB8 cable modem signal quality. Good: DS SNR >30dB, DS Power -7 to +7 dBmV, US Power 35-51 dBmV. ISP reports upstream correctable errors causing issues - watch for US Power spikes or SNR drops correlating with outages. Click legend items to show/hide lines.</div>
                <canvas id="modemChart"></canvas>
                <div id="modemRestarts" style="font-size: 10px; color: #ff8800; margin-top: 5px;"></div>
            </div>
            
            <div class="chart-container" id="heatmapContainer" style="display: none;">
                <h2>üî• Packet Loss Heatmap by Hour (Mountain Time)</h2>
                <div class="chart-subtitle">Shows average packet loss percentage by hour of day in Mountain Time. Darker red indicates worse packet loss. Helps identify time-based patterns like evening congestion or interference.</div>
                <canvas id="heatmapChart" style="max-height: 150px;"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>üå°Ô∏è Weather - Calgary</h2>
                <div class="chart-subtitle">Temperature and precipitation data for Calgary. Weather conditions can affect cable signal quality through temperature changes, moisture, and ice buildup on lines.</div>
                <canvas id="weatherChart"></canvas>
            </div>
            
            <div class="chart-container">
                <h2>‚ö†Ô∏è Codeword Error Rate - Top 5 Worst Channels</h2>
                <div class="chart-subtitle">Rate of change in codeword errors for the 5 worst downstream channels (per 5 min). Correctable errors (solid lines) indicate line quality degradation before packet loss occurs. Uncorrectable errors (dashed lines) mean data corruption. Spikes during evening outages confirm physical layer issues. Click legend items to show/hide lines.</div>
                <canvas id="errorChart"></canvas>
                <div id="errorRestarts" style="font-size: 10px; color: #ff8800; margin-top: 5px;"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Chart.js plugin to draw time-of-day background shading
        const timeOfDayPlugin = {
            id: 'timeOfDay',
            beforeDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const chartArea = chart.chartArea;
                
                if (!xAxis || !chart.data.labels.length) return;
                
                // Define time periods (hours in 24h format)
                const periods = [
                    { start: 0, end: 6, color: 'rgba(50, 50, 100, 0.25)', label: 'Night' },
                    { start: 6, end: 12, color: 'rgba(255, 200, 100, 0.15)', label: 'Morning' },
                    { start: 12, end: 18, color: 'rgba(100, 200, 255, 0.12)', label: 'Afternoon' },
                    { start: 18, end: 24, color: 'rgba(150, 100, 200, 0.2)', label: 'Evening' }
                ];
                
                // Get time range from chart
                const startTime = new Date(chart.data.labels[0]).getTime();
                const endTime = new Date(chart.data.labels[chart.data.labels.length - 1]).getTime();
                
                // Draw bands for each hour in the visible range
                for (let time = startTime; time <= endTime; time += 3600000) { // 1 hour increments
                    const date = new Date(time);
                    const hour = date.getHours();
                    
                    const period = periods.find(p => hour >= p.start && hour < p.end);
                    if (!period) continue;
                    
                    const x1 = xAxis.getPixelForValue(time);
                    const x2 = xAxis.getPixelForValue(time + 3600000); // Next hour
                    
                    if (x1 >= chartArea.left && x1 <= chartArea.right) {
                        ctx.save();
                        ctx.fillStyle = period.color;
                        ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
                        ctx.restore();
                    }
                }
            }
        };
        
        // Chart.js plugin to draw vertical lines for restarts
        const verticalLinePlugin = {
            id: 'verticalLine',
            afterDatasetsDraw: (chart) => {
                if (chart.config.options.verticalLines && chart.config.options.verticalLines.length > 0) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    const chartArea = chart.chartArea;
                    
                    chart.config.options.verticalLines.forEach(timestamp => {
                        const restartTime = new Date(timestamp).getTime();
                        
                        // Use time scale's getPixelForValue with actual timestamp
                        const x = xAxis.getPixelForValue(restartTime);
                        
                        // Only draw if within chart area
                        if (x >= chartArea.left && x <= chartArea.right) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(x, chartArea.top - 50);
                            ctx.lineTo(x, chartArea.bottom + 50);
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = '#ff8800';
                            ctx.setLineDash([5, 5]);
                            ctx.stroke();
                            ctx.restore();
                        }
                    });
                }
            }
        };
        
        Chart.register(timeOfDayPlugin, verticalLinePlugin);
        
        // Get initial range from URL or default to 24 hours
        const urlParams = new URLSearchParams(window.location.search);
        let currentRange = urlParams.get('range') === 'null' ? null : (parseInt(urlParams.get('range')) || 1440);
        let speedChart, latencyChart, cmtsChart, modemChart, errorChart, heatmapChart, weatherChart;
        
        function updateRange(range) {
            currentRange = range;
            
            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('range', range === null ? 'null' : range);
            window.history.replaceState({}, '', url);
            
            document.querySelectorAll('.time-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            fetchData(true);
        }
        
        let modemRestarts = [];
        let modemUptimeSeconds = null;
        let modemUptimeTimestamp = null;
        
        function fetchData(showLoading = false) {
            if (showLoading) {
                document.getElementById('loadingIndicator').classList.add('show');
            }
            const url = currentRange ? `/api/network/data?minutes=${currentRange}` : '/api/network/data';
            fetch(url)
                .then(res => res.json())
                .then(data => {
                    if (showLoading) {
                        document.getElementById('loadingIndicator').classList.remove('show');
                    }
                    modemRestarts = data.restarts || [];
                    modemUptimeSeconds = data.uptime_seconds;
                    modemUptimeTimestamp = data.uptime_timestamp;
                    updateCharts(data.tests, data.top_channels || [], data.hourly_avg || [], data.weather || [], data.speed_tests || []);
                    updateSummary(data.summary, data.tests);
                    updateLabels(data);
                    // Use latest speed test from timespan if available, otherwise use latest_speed
                    const speedTestsInTimespan = data.speed_tests || [];
                    const latestInTimespan = speedTestsInTimespan.length > 0 ? speedTestsInTimespan[speedTestsInTimespan.length - 1] : null;
                    const speedToShow = latestInTimespan || data.latest_speed;
                    updateSpeedCards(speedToShow);
                    const nodeIdSpan = document.getElementById('nodeId');
                    if (nodeIdSpan) nodeIdSpan.textContent = data.node_id || 'Unknown';
                    const lastUpdateDiv = document.getElementById('lastUpdate');
                    if (lastUpdateDiv) {
                        lastUpdateDiv.innerHTML = `Last Update: ${new Date().toLocaleString()} (Times in Mountain Time) | Showing ${data.tests.length} points | Node: <span id="nodeId">${data.node_id || 'Unknown'}</span>`;
                    }
                })
                .catch(err => {
                    if (showLoading) {
                        document.getElementById('loadingIndicator').classList.remove('show');
                    }
                    console.error('Error fetching data:', err);
                });
        }
        
        function updateLabels(data) {
            const pingName = data.ping_target_name || 'Google DNS';
            const pingTarget = data.ping_target || '8.8.8.8';
            const cmtsTarget = data.cmts_target || 'N/A';
            
            // Update section headers
            document.querySelectorAll('h2').forEach(h2 => {
                if (h2.textContent.includes('Google DNS')) {
                    h2.innerHTML = `üåê ${pingName} (${pingTarget})`;
                } else if (h2.textContent.includes('CMTS')) {
                    h2.innerHTML = `üì° CMTS (${cmtsTarget})`;
                }
            });
        }
        
        function updateSpeedCards(latestSpeed) {
            const downloadEl = document.getElementById('latestDownload');
            const uploadEl = document.getElementById('latestUpload');
            if (latestSpeed) {
                downloadEl.innerHTML = `${latestSpeed.download.toFixed(0)}<span style="font-size: 16px;">Mbps</span>`;
                uploadEl.innerHTML = `${latestSpeed.upload.toFixed(0)}<span style="font-size: 16px;">Mbps</span>`;
                document.getElementById('downloadTime').textContent = latestSpeed.timestamp;
                document.getElementById('uploadTime').textContent = latestSpeed.timestamp;
            } else {
                downloadEl.innerHTML = '-<span style="font-size: 16px;">Mbps</span>';
                uploadEl.innerHTML = '-<span style="font-size: 16px;">Mbps</span>';
                document.getElementById('downloadTime').textContent = 'No data';
                document.getElementById('uploadTime').textContent = 'No data';
            }
        }
        
        
        function updateCharts(tests, topChannels, hourlyAvg, weather, speedTests) {
            // Filter out last test if it has 0 ping (incomplete/failed test)
            if (tests.length > 0 && tests[tests.length - 1].ping === 0) {
                tests = tests.slice(0, -1);
            }
            
            const timestamps = tests.map(t => t.timestamp);
            const pings = tests.map(t => t.ping || 0);
            const packetLosses = tests.map(t => t.packet_loss);
            const cmtsPings = tests.map(t => t.cmts_ping || 0);
            const cmtsPacketLosses = tests.map(t => t.cmts_packet_loss || 0);
            
            // Use speed test timestamps directly (don't merge with ping timestamps)
            const speedTimestamps = speedTests.map(st => st.timestamp);
            const downloads = speedTests.map(st => st.download);
            const uploads = speedTests.map(st => st.upload);
            
            // Create restart marker points
            const restartMarkers = timestamps.map(ts => {
                return modemRestarts.includes(ts) ? 1 : null;
            });
            
            // Modem signals
            const modemDsSNR = tests.map(t => t.modem_ds_snr || null);
            const modemDsPower = tests.map(t => t.modem_ds_power || null);
            const modemUsPower = tests.map(t => t.modem_us_power || null);
            
            // Calculate error rates (change per interval) - top 5 channels
            const channelRates = {};
            topChannels.forEach(ch => {
                channelRates[ch] = { correctable: [], uncorrectable: [] };
            });
            
            // Find tests with channel data
            const testsWithChannels = [];
            for (let i = 0; i < tests.length; i++) {
                if (tests[i].channels) {
                    testsWithChannels.push(i);
                }
            }
            
            for (let i = 0; i < tests.length; i++) {
                topChannels.forEach(ch => {
                    const chStr = String(ch);
                    const curr = tests[i].channels?.[chStr];
                    
                    // Find previous test with channel data
                    let prevIdx = -1;
                    for (let j = i - 1; j >= 0; j--) {
                        if (tests[j].channels?.[chStr]) {
                            prevIdx = j;
                            break;
                        }
                    }
                    const prev = prevIdx >= 0 ? tests[prevIdx].channels[chStr] : null;
                    
                    if (curr && prev && curr.correctable !== null && prev.correctable !== null) {
                        const corrDelta = Math.max(0, curr.correctable - prev.correctable);
                        const uncorrDelta = Math.max(0, curr.uncorrectable - prev.uncorrectable);
                        channelRates[ch].correctable.push(corrDelta);
                        channelRates[ch].uncorrectable.push(uncorrDelta);
                    } else {
                        channelRates[ch].correctable.push(null);
                        channelRates[ch].uncorrectable.push(null);
                    }
                });
            }
            
            // Check if there are any speed tests in the current timespan
            const hasSpeedTests = downloads.some(d => d !== null) || uploads.some(u => u !== null);
            const speedChartContainer = document.getElementById('speedChartContainer');
            
            if (!hasSpeedTests) {
                // Hide chart if no speed tests in timespan
                if (speedChartContainer) speedChartContainer.style.display = 'none';
            } else {
                // Show chart if there are speed tests
                if (speedChartContainer) speedChartContainer.style.display = 'block';
            }
            
            if (!speedChart && hasSpeedTests) {
                speedChart = new Chart(document.getElementById('speedChart'), {
                    type: 'line',
                    data: {
                        labels: speedTimestamps,
                        datasets: [{
                            label: 'Download',
                            data: downloads,
                            borderColor: '#00ff88',
                            backgroundColor: 'rgba(0, 255, 136, 0.3)',
                            borderWidth: 2,
                            tension: 0,
                            spanGaps: false,
                            fill: true,
                            pointRadius: 4,
                            pointBackgroundColor: '#00ff88'
                        }, {
                            label: 'Upload',
                            data: uploads,
                            borderColor: '#0088ff',
                            backgroundColor: 'rgba(0, 136, 255, 0.3)',
                            borderWidth: 2,
                            tension: 0,
                            spanGaps: false,
                            fill: true,
                            pointRadius: 4,
                            pointBackgroundColor: '#0088ff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        verticalLines: modemRestarts,
                        plugins: { 
                            legend: { labels: { color: '#e0e0e0' } }
                        },
                        scales: {
                            x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                type: 'time',
                                time: {
                                    displayFormats: {
                                        hour: 'MMM d, ha',
                                        day: 'MMM d'
                                    }
                                },
                                ticks: { color: '#888', maxTicksLimit: 10 }, 
                                grid: { color: '#333' }
                            },
                            y: { ticks: { color: '#888' }, grid: { color: '#333' }, beginAtZero: true }
                        }
                    }
                });
            }
                
            if (!latencyChart) {
                latencyChart = new Chart(document.getElementById('latencyChart'), {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: [{
                            label: 'Latency (ms)',
                            data: pings,
                            borderColor: '#cc8800',
                            backgroundColor: 'rgba(204, 136, 0, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y',
                            fill: true
                        }, {
                            label: 'Packet Loss (%)',
                            data: packetLosses,
                            borderColor: '#ff4444',
                            backgroundColor: 'rgba(255, 68, 68, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y1',
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        verticalLines: modemRestarts,
                        plugins: { 
                            legend: { labels: { color: '#e0e0e0' } }
                        },
                        scales: {
                            x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                ticks: { color: '#888', maxTicksLimit: 10 }, 
                                grid: { color: '#333' }
                            },
                            y: { type: 'linear', position: 'left', ticks: { color: '#cc8800' }, grid: { color: '#333' }, title: { display: true, text: 'Latency (ms)', color: '#cc8800' } },
                            y1: { type: 'linear', position: 'right', ticks: { color: '#ff4444' }, grid: { display: false }, title: { display: true, text: 'Packet Loss (%)', color: '#ff4444' }, max: 100 }
                        }
                    }
                });
            }
                
            if (!cmtsChart) {
                cmtsChart = new Chart(document.getElementById('cmtsChart'), {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: [{
                            label: 'CMTS Latency (ms)',
                            data: cmtsPings,
                            borderColor: '#9966ff',
                            backgroundColor: 'rgba(153, 102, 255, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y',
                            fill: true
                        }, {
                            label: 'CMTS Packet Loss (%)',
                            data: cmtsPacketLosses,
                            borderColor: '#ff6699',
                            backgroundColor: 'rgba(255, 102, 153, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y1',
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        verticalLines: modemRestarts,
                        plugins: { 
                            legend: { labels: { color: '#e0e0e0' } }
                        },
                        scales: {
                            x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                ticks: { color: '#888', maxTicksLimit: 10 }, 
                                grid: { color: '#333' }
                            },
                            y: { type: 'linear', position: 'left', ticks: { color: '#9966ff' }, grid: { color: '#333' }, title: { display: true, text: 'Latency (ms)', color: '#9966ff' } },
                            y1: { type: 'linear', position: 'right', ticks: { color: '#ff6699' }, grid: { display: false }, title: { display: true, text: 'Packet Loss (%)', color: '#ff6699' }, max: 100 }
                        }
                    }
                });
            }
                
            if (!modemChart) {
                modemChart = new Chart(document.getElementById('modemChart'), {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: [{
                            label: 'DS SNR (dB)',
                            data: modemDsSNR,
                            borderColor: '#00ffff',
                            backgroundColor: 'rgba(0, 255, 255, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y',
                            fill: true,
                            spanGaps: true
                        }, {
                            label: 'DS Power (dBmV)',
                            data: modemDsPower,
                            borderColor: '#ffff00',
                            backgroundColor: 'rgba(255, 255, 0, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y1',
                            fill: true,
                            spanGaps: true
                        }, {
                            label: 'US Power (dBmV)',
                            data: modemUsPower,
                            borderColor: '#ff00ff',
                            backgroundColor: 'rgba(255, 0, 255, 0.2)',
                            borderWidth: 2,
                            tension: 0,
                            yAxisID: 'y2',
                            fill: true,
                            spanGaps: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        verticalLines: modemRestarts,
                        plugins: { 
                            legend: { labels: { color: '#e0e0e0' } }
                        },
                        scales: {
                            x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                ticks: { color: '#888', maxTicksLimit: 10 }, 
                                grid: { color: '#333' }
                            },
                            y: { type: 'linear', position: 'left', ticks: { color: '#00ffff' }, grid: { color: '#333' }, title: { display: true, text: 'DS SNR (dB)', color: '#00ffff' } },
                            y1: { type: 'linear', position: 'right', ticks: { color: '#ffff00' }, grid: { display: false }, title: { display: true, text: 'DS Power (dBmV)', color: '#ffff00' } },
                            y2: { type: 'linear', position: 'right', ticks: { color: '#ff00ff' }, grid: { display: false }, title: { display: true, text: 'US Power (dBmV)', color: '#ff00ff' } }
                        }
                    }
                });
            }
                
            if (!errorChart && topChannels.length > 0) {
                errorChart = new Chart(document.getElementById('errorChart'), {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: topChannels.flatMap(ch => [
                            {
                                label: `Ch${ch} Correctable/5min`,
                                data: channelRates[ch].correctable,
                                borderColor: `hsl(${ch * 11}, 70%, 50%)`,
                                backgroundColor: `hsla(${ch * 11}, 70%, 50%, 0.2)`,
                                borderWidth: 2,
                                tension: 0,
                                yAxisID: 'y',
                                fill: false,
                                spanGaps: true,
                                hidden: localStorage.getItem(`legend_Ch${ch}_Correctable`) === 'false'
                            },
                            {
                                label: `Ch${ch} Uncorrectable/5min`,
                                data: channelRates[ch].uncorrectable,
                                borderColor: `hsl(${ch * 11 + 180}, 70%, 50%)`,
                                backgroundColor: `hsla(${ch * 11 + 180}, 70%, 50%, 0.2)`,
                                borderWidth: 2,
                                tension: 0,
                                yAxisID: 'y',
                                fill: false,
                                spanGaps: true,
                                borderDash: [5, 5],
                                hidden: localStorage.getItem(`legend_Ch${ch}_Uncorrectable`) === 'false'
                            }
                        ])
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        verticalLines: modemRestarts,
                        plugins: { 
                            legend: { labels: { color: '#e0e0e0' } }
                        },
                        scales: {
                            x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                ticks: { color: '#888', maxTicksLimit: 10 }, 
                                grid: { color: '#333' }
                            },
                            y: { type: 'linear', position: 'left', ticks: { color: '#ffaa00' }, grid: { color: '#333' }, title: { display: true, text: 'Errors per 5 min', color: '#ffaa00' }, beginAtZero: true }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#e0e0e0' },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                meta.hidden = !meta.hidden;
                                chart.update();
                                // Save state
                                const key = chart.data.datasets[index].label.replace('/5min', '').replace(' ', '_');
                                localStorage.setItem(`legend_${key}`, !meta.hidden);
                            }
                        }
                    }
                });
            }
            
            // Update charts
            if (hasSpeedTests && speedChart) {
                speedChart.data.labels = speedTimestamps;
                speedChart.data.datasets[0].data = downloads;
                speedChart.data.datasets[1].data = uploads;
                speedChart.options.verticalLines = modemRestarts;
                speedChart.update();
            }
            
            if (latencyChart) {
                latencyChart.data.labels = timestamps;
                latencyChart.data.datasets[0].data = pings;
                latencyChart.data.datasets[1].data = packetLosses;
                latencyChart.options.verticalLines = modemRestarts;
                latencyChart.update();
            }
            
            if (cmtsChart) {
                cmtsChart.data.labels = timestamps;
                cmtsChart.data.datasets[0].data = cmtsPings;
                cmtsChart.data.datasets[1].data = cmtsPacketLosses;
                cmtsChart.options.verticalLines = modemRestarts;
                cmtsChart.update();
            }
            
            if (modemChart) {
                modemChart.data.labels = timestamps;
                modemChart.data.datasets[0].data = modemDsSNR;
                modemChart.data.datasets[1].data = modemDsPower;
                modemChart.data.datasets[2].data = modemUsPower;
                modemChart.options.verticalLines = modemRestarts;
                modemChart.update();
            }
            
            if (errorChart && topChannels.length > 0) {
                // Save current hidden states before updating
                const hiddenStates = errorChart.data.datasets.map((ds, i) => {
                    const meta = errorChart.getDatasetMeta(i);
                    return meta.hidden;
                });
                
                errorChart.data.labels = timestamps;
                errorChart.data.datasets = topChannels.flatMap(ch => [
                {
                    label: `Ch${ch} Correctable/5min`,
                    data: channelRates[ch].correctable,
                    borderColor: `hsl(${ch * 11}, 70%, 50%)`,
                    backgroundColor: `hsla(${ch * 11}, 70%, 50%, 0.2)`,
                    borderWidth: 2,
                        tension: 0,
                        yAxisID: 'y',
                        fill: false,
                        spanGaps: true
                    },
                    {
                        label: `Ch${ch} Uncorrectable/5min`,
                        data: channelRates[ch].uncorrectable,
                        borderColor: `hsl(${ch * 11}, 70%, 50%)`,
                        backgroundColor: `hsla(${ch * 11}, 70%, 50%, 0.2)`,
                        borderWidth: 2,
                        tension: 0,
                        yAxisID: 'y',
                        fill: false,
                        spanGaps: true,
                        borderDash: [5, 5]
                    }
                ]);
                
                // Restore hidden states after updating datasets
                errorChart.data.datasets.forEach((ds, i) => {
                    if (i < hiddenStates.length) {
                        const meta = errorChart.getDatasetMeta(i);
                        meta.hidden = hiddenStates[i];
                    }
                });
                
                errorChart.options.verticalLines = modemRestarts;
                errorChart.update();
            } else if (!errorChart && topChannels.length > 0) {
                // Create chart if it doesn't exist yet but we now have data
                errorChart = new Chart(document.getElementById('errorChart'), {
                    type: 'line',
                    data: {
                        labels: timestamps,
                            datasets: topChannels.flatMap(ch => [
                                {
                                    label: `Ch${ch} Correctable/5min`,
                                    data: channelRates[ch].correctable,
                                    borderColor: `hsl(${ch * 11}, 70%, 50%)`,
                                    backgroundColor: `hsla(${ch * 11}, 70%, 50%, 0.2)`,
                                    borderWidth: 2,
                                    tension: 0,
                                    yAxisID: 'y',
                                    fill: false,
                                    spanGaps: true
                                },
                                {
                                    label: `Ch${ch} Uncorrectable/5min`,
                                    data: channelRates[ch].uncorrectable,
                                    borderColor: `hsl(${ch * 11 + 180}, 70%, 50%)`,
                                    backgroundColor: `hsla(${ch * 11 + 180}, 70%, 50%, 0.2)`,
                                    borderWidth: 2,
                                    tension: 0,
                                    yAxisID: 'y',
                                    fill: false,
                                    spanGaps: true,
                                    borderDash: [5, 5],
                                    hidden: localStorage.getItem(`legend_Ch${ch}_Uncorrectable`) === 'false'
                                }
                            ]).concat([{
                            }])
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            animation: { duration: 750 },
                        verticalLines: modemRestarts,
                            plugins: { 
                                legend: { 
                                    labels: { color: '#e0e0e0' },
                                    onClick: (e, legendItem, legend) => {
                                        const index = legendItem.datasetIndex;
                                        const chart = legend.chart;
                                        const meta = chart.getDatasetMeta(index);
                                        meta.hidden = !meta.hidden;
                                        chart.update();
                                        // Save state
                                        const key = chart.data.datasets[index].label.replace('/5min', '').replace(' ', '_');
                                        localStorage.setItem(`legend_${key}`, !meta.hidden);
                                    }
                                }
                            },
                            scales: {
                                x: { type: 'time', time: { displayFormats: { hour: 'MMM d, ha', day: 'MMM d' } }, 
                                    ticks: { color: '#888', maxTicksLimit: 10 }, 
                                    grid: { color: '#333' }
                                },
                                y: { type: 'linear', position: 'left', ticks: { color: '#ffaa00' }, grid: { color: '#333' }, title: { display: true, text: 'Errors per 5 min', color: '#ffaa00' }, beginAtZero: true }
                            }
                        }
                    });
                }
            
            // Create hourly heatmap data - only show if viewing >= 6 hours
            const showHeatmap = currentRange === null || currentRange >= 360;
            document.getElementById('heatmapContainer').style.display = showHeatmap ? 'block' : 'none';
            
            if (showHeatmap && hourlyAvg && !heatmapChart) {
                heatmapChart = new Chart(document.getElementById('heatmapChart'), {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                        datasets: [{
                            label: 'Avg Packet Loss %',
                            data: hourlyAvg,
                            backgroundColor: hourlyAvg.map(v => `rgba(255, ${Math.max(0, 255 - v*3)}, 0, ${0.3 + v/100})`),
                            borderColor: hourlyAvg.map(v => `rgb(255, ${Math.max(0, 255 - v*3)}, 0)`),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        animation: { duration: 750 },
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { ticks: { color: '#888' }, grid: { color: '#333' } },
                            y: { ticks: { color: '#888' }, grid: { color: '#333' }, beginAtZero: true, title: { display: true, text: 'Packet Loss %', color: '#888' } }
                        }
                    }
                });
            } else if (heatmapChart && showHeatmap && hourlyAvg) {
                heatmapChart.data.datasets[0].data = hourlyAvg;
                heatmapChart.data.datasets[0].backgroundColor = hourlyAvg.map(v => `rgba(255, ${Math.max(0, 255 - v*3)}, 0, ${0.3 + v/100})`);
                heatmapChart.data.datasets[0].borderColor = hourlyAvg.map(v => `rgb(255, ${Math.max(0, 255 - v*3)}, 0)`);
                heatmapChart.update();
            }
            
            // Weather chart
            if (weather && weather.length > 0) {
                const weatherTimestamps = weather.map(w => w.timestamp);
                const temperatures = weather.map(w => w.temperature);
                const precipitation = weather.map(w => w.precipitation);
                
                if (!weatherChart) {
                    weatherChart = new Chart(document.getElementById('weatherChart'), {
                        type: 'line',
                        data: {
                            labels: weatherTimestamps,
                            datasets: [{
                                label: 'Temperature (¬∞C)',
                                data: temperatures,
                                borderColor: '#ff6b6b',
                                backgroundColor: 'rgba(255, 107, 107, 0.2)',
                                borderWidth: 2,
                                tension: 0,
                                yAxisID: 'y',
                                fill: true
                            }, {
                                label: 'Precipitation (mm)',
                                data: precipitation,
                                borderColor: '#4ecdc4',
                                backgroundColor: 'rgba(78, 205, 196, 0.2)',
                                borderWidth: 2,
                                tension: 0,
                                yAxisID: 'y1',
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            animation: { duration: 750 },
                            verticalLines: modemRestarts,
                            plugins: { legend: { labels: { color: '#e0e0e0' } } },
                            scales: {
                                x: { 
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            hour: 'MMM d, ha',
                                            day: 'MMM d'
                                        }
                                    },
                                    ticks: { color: '#888', maxTicksLimit: 10 }, 
                                    grid: { color: '#333' } 
                                },
                                y: { type: 'linear', position: 'left', ticks: { color: '#ff6b6b' }, grid: { color: '#333' }, title: { display: true, text: 'Temperature (¬∞C)', color: '#ff6b6b' } },
                                y1: { type: 'linear', position: 'right', ticks: { color: '#4ecdc4' }, grid: { display: false }, title: { display: true, text: 'Precipitation (mm)', color: '#4ecdc4' }, beginAtZero: true }
                            }
                        }
                    });
                } else {
                    weatherChart.data.labels = weatherTimestamps;
                    weatherChart.data.datasets[0].data = temperatures;
                    weatherChart.data.datasets[1].data = precipitation;
                    weatherChart.options.verticalLines = modemRestarts;
                    weatherChart.update();
                }
            }
            
            // Update restart indicators - show all restarts, not just those matching test timestamps
            const restartText = modemRestarts.length > 0 
                ? `üîÑ Modem Restarts (orange dashed line): ${modemRestarts.join(', ')}`
                : '';
            document.getElementById('latencyRestarts').textContent = restartText;
            document.getElementById('cmtsRestarts').textContent = restartText;
            document.getElementById('speedRestarts').textContent = restartText;
            document.getElementById('modemRestarts').textContent = restartText;
            document.getElementById('errorRestarts').textContent = restartText;
        }
        
        function updateSummary(summary, tests) {
            document.getElementById('totalTests').textContent = summary.total_tests;
            document.getElementById('highLatency').textContent = summary.high_latency;
            document.getElementById('googlePacketLossCount').textContent = summary.google_packet_loss;
            document.getElementById('cmtsPacketLossCount').textContent = summary.cmts_packet_loss;
            document.getElementById('failures').textContent = summary.failures;
            document.getElementById('avgLatency').innerHTML = summary.avg_latency + '<span style="font-size: 16px;">ms</span>';
            document.getElementById('avgPacketLoss').innerHTML = summary.avg_packet_loss + '<span style="font-size: 16px;">%</span>';
            document.getElementById('avgCmtsLatency').innerHTML = summary.avg_cmts_latency + '<span style="font-size: 16px;">ms</span>';
            document.getElementById('avgCmtsPacketLoss').innerHTML = summary.avg_cmts_packet_loss + '<span style="font-size: 16px;">%</span>';
            document.getElementById('latencyDiff').innerHTML = summary.latency_diff + '<span style="font-size: 16px;">ms</span>';
            
            const highLatency = summary.high_latency;
            const googlePacketLoss = summary.google_packet_loss;
            const cmtsPacketLoss = summary.cmts_packet_loss;
            const failures = summary.failures;
            const avgPing = summary.avg_latency;
            const avgPacketLoss = summary.avg_packet_loss;
            const avgCmtsPing = summary.avg_cmts_latency;
            
            // Modem signals and worst channel need full test data
            const testsWithModem = tests.filter(t => t.modem_ds_snr !== undefined);
            const testsWithChannels = tests.filter(t => t.channels);
            const latestChannelTest = testsWithChannels.length > 0 ? testsWithChannels[testsWithChannels.length - 1] : null;
            let worstChannel = null;
            if (latestChannelTest && latestChannelTest.channels) {
                let maxErrors = 0;
                for (const [chId, data] of Object.entries(latestChannelTest.channels)) {
                    const total = (data.correctable || 0) + (data.uncorrectable || 0);
                    if (total > maxErrors) {
                        maxErrors = total;
                        worstChannel = { id: chId, correctable: data.correctable, uncorrectable: data.uncorrectable };
                    }
                }
            }
            
            // Worst channel errors
            if (worstChannel) {
                document.getElementById('worstChannelId').textContent = worstChannel.id;
                document.getElementById('worstChannelCorr').textContent = (worstChannel.correctable / 1000000).toFixed(1) + 'M';
                document.getElementById('worstChannelUncorr').textContent = (worstChannel.uncorrectable / 1000000).toFixed(1) + 'M';
                document.getElementById('worstChannelCorrCard').className = worstChannel.correctable > 10000000 ? 'stat-card warning' : 'stat-card';
                document.getElementById('worstChannelUncorrCard').className = worstChannel.uncorrectable > 1000000 ? 'stat-card error' : 'stat-card';
            } else {
                document.getElementById('worstChannelId').textContent = '-';
                document.getElementById('worstChannelCorr').textContent = '-';
                document.getElementById('worstChannelUncorr').textContent = '-';
            }
            
            // Modem signals - calculate ranges
            if (testsWithModem.length > 0) {
                const snrValues = testsWithModem.map(t => t.modem_ds_snr).filter(v => v !== undefined);
                const dsPowerValues = testsWithModem.map(t => t.modem_ds_power).filter(v => v !== undefined);
                const usPowerValues = testsWithModem.map(t => t.modem_us_power).filter(v => v !== undefined);
                
                const avgSNR = snrValues.length > 0 ? (snrValues.reduce((a,b) => a+b, 0) / snrValues.length).toFixed(1) : null;
                const minSNR = snrValues.length > 0 ? Math.min(...snrValues).toFixed(1) : null;
                const maxSNR = snrValues.length > 0 ? Math.max(...snrValues).toFixed(1) : null;
                
                const avgDsPower = dsPowerValues.length > 0 ? (dsPowerValues.reduce((a,b) => a+b, 0) / dsPowerValues.length).toFixed(1) : null;
                const minDsPower = dsPowerValues.length > 0 ? Math.min(...dsPowerValues).toFixed(1) : null;
                const maxDsPower = dsPowerValues.length > 0 ? Math.max(...dsPowerValues).toFixed(1) : null;
                
                const avgUsPower = usPowerValues.length > 0 ? (usPowerValues.reduce((a,b) => a+b, 0) / usPowerValues.length).toFixed(1) : null;
                const minUsPower = usPowerValues.length > 0 ? Math.min(...usPowerValues).toFixed(1) : null;
                const maxUsPower = usPowerValues.length > 0 ? Math.max(...usPowerValues).toFixed(1) : null;
                
                document.getElementById('modemDsSNR').innerHTML = avgSNR + '<span style="font-size: 16px;">dB</span>';
                document.getElementById('modemDsSNRRange').textContent = `${minSNR} - ${maxSNR} dB`;
                document.getElementById('modemDsSNRCard').className = avgSNR < 30 ? 'stat-card warning' : 'stat-card';
                
                document.getElementById('modemDsPower').innerHTML = avgDsPower + '<span style="font-size: 16px;">dBmV</span>';
                document.getElementById('modemDsPowerRange').textContent = `${minDsPower} - ${maxDsPower} dBmV`;
                document.getElementById('modemDsPowerCard').className = (avgDsPower < -7 || avgDsPower > 7) ? 'stat-card warning' : 'stat-card';
                
                document.getElementById('modemUsPower').innerHTML = avgUsPower + '<span style="font-size: 16px;">dBmV</span>';
                document.getElementById('modemUsPowerRange').textContent = `${minUsPower} - ${maxUsPower} dBmV`;
                document.getElementById('modemUsPowerCard').className = (avgUsPower < 35 || avgUsPower > 51) ? 'stat-card warning' : 'stat-card';
            } else {
                document.getElementById('modemDsSNR').innerHTML = '-<span style="font-size: 16px;">dB</span>';
                document.getElementById('modemDsSNRRange').textContent = '-';
                document.getElementById('modemDsPower').innerHTML = '-<span style="font-size: 16px;">dBmV</span>';
                document.getElementById('modemDsPowerRange').textContent = '-';
                document.getElementById('modemUsPower').innerHTML = '-<span style="font-size: 16px;">dBmV</span>';
                document.getElementById('modemUsPowerRange').textContent = '-';
            }
            
            // Update uptime
            if (modemUptimeSeconds !== null) {
                const days = Math.floor(modemUptimeSeconds / 86400);
                const hours = Math.floor((modemUptimeSeconds % 86400) / 3600);
                const minutes = Math.floor((modemUptimeSeconds % 3600) / 60);
                document.getElementById('modemUptime').textContent = `${days}d ${hours}h ${minutes}m`;
                if (modemUptimeTimestamp) {
                    const checkedDate = new Date(modemUptimeTimestamp + ' UTC');
                    document.getElementById('modemUptimeChecked').textContent = `Checked: ${checkedDate.toLocaleString('en-US', { timeZone: 'America/Denver' })}`;
                }
            } else {
                document.getElementById('modemUptime').textContent = '-';
                document.getElementById('modemUptimeChecked').textContent = '-';
            }
            
            document.getElementById('highLatencyCard').className = highLatency > 0 ? 'stat-card warning' : 'stat-card';
            document.getElementById('googlePacketLossCard').className = googlePacketLoss > 0 ? 'stat-card warning' : 'stat-card';
            document.getElementById('cmtsPacketLossCard').className = cmtsPacketLoss > 0 ? 'stat-card warning' : 'stat-card';
            document.getElementById('failuresCard').className = failures > 0 ? 'stat-card error' : 'stat-card';
            document.getElementById('avgLatencyCard').className = avgPing > 30 ? 'stat-card warning' : 'stat-card';
            document.getElementById('avgPacketLossCard').className = avgPacketLoss > 10 ? 'stat-card warning' : 'stat-card';
            document.getElementById('avgCmtsLatencyCard').className = avgCmtsPing > 30 ? 'stat-card warning' : 'stat-card';
            document.getElementById('avgCmtsPacketLossCard').className = avgCmtsPacketLoss > 10 ? 'stat-card warning' : 'stat-card';
            document.getElementById('latencyDiffCard').className = latencyDiff > 20 ? 'stat-card warning' : 'stat-card';
        }
        
        // Initial load and auto-refresh every 10 seconds
        // Set active button based on URL parameter
        document.querySelectorAll('.time-btn').forEach(btn => {
            const onclick = btn.getAttribute('onclick');
            const match = onclick.match(/updateRange\((\d+|null)\)/);
            if (match) {
                const btnRange = match[1] === 'null' ? null : parseInt(match[1]);
                if (btnRange === currentRange) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        });
        
        fetchData();
        setInterval(fetchData, 10000);
    </script>
</body>
</html>
